"use strict";var h=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var l=Object.prototype.hasOwnProperty;var N=(r,t,e,u)=>{if(t&&typeof t=="object"||typeof t=="function")for(let s of p(t))!l.call(r,s)&&s!==e&&h(r,s,{get:()=>t[s],enumerable:!(u=f(t,s))||u.enumerable});return r};var g=r=>N(h({},"__esModule",{value:!0}),r);var x={};module.exports=g(x);var n=class extends String{static name="";static handler(...t){throw new Error("Method not implemented.")}};var a=class extends n{static name="greaterThan";static handler(...t){if(t.length!==1)throw new Error("Greater Than Extension requires one argument.");let e=t[0];if(typeof e!="string")throw new Error("Greater Than Extension requires a string argument.");return!isNaN(Number(this))&&!isNaN(Number(e))?Number(this)>Number(e):!isNaN(Date.parse(this.valueOf()))&&!isNaN(Date.parse(e))?new Date(this.valueOf()).getTime()>new Date(e).getTime():this.valueOf()>e}};var i=class extends n{static name="lessThan";static handler(...t){if(t.length!==1)throw new Error("Less Than Extension requires one argument.");let e=t[0];if(typeof e!="string")throw new Error("Less Than Extension requires a string argument.");return!isNaN(Number(this))&&!isNaN(Number(e))?Number(this)<Number(e):!isNaN(Date.parse(this.valueOf()))&&!isNaN(Date.parse(e))?new Date(this.valueOf()).getTime()<new Date(e).getTime():this.valueOf()<e}};var o=class extends n{static name="equal";static handler(...t){if(t.length!==1)throw new Error("Equal Extension requires one argument.");let e=t[0];if(typeof e!="string")throw new Error("Equal Extension requires a string argument.");return!isNaN(Number(this))&&!isNaN(Number(e))?Number(this)===Number(e):!isNaN(Date.parse(this.valueOf()))&&!isNaN(Date.parse(e))?new Date(this.valueOf()).getTime()===new Date(e).getTime():this.valueOf()===e}};var m={[a.name]:a.handler,[i.name]:i.handler,[o.name]:o.handler};var c=String.prototype;for(let r of Object.keys(m))c[r]=function(...t){return m[r].apply(this,t)};
//# sourceMappingURL=index.cjs.map