{"version":3,"sources":["../src/extension/interface.ts","../src/extension/greaterthan.ts","../src/extension/lessthan.ts","../src/extension/equal.ts","../src/extension/index.ts","../src/index.ts"],"sourcesContent":["export abstract class Extension extends String {\n  static name: string = \"\" as const;\n  static async handler(...args: any[]): Promise<boolean | undefined> {\n    throw new Error(\"Method not implemented.\");\n  }\n}","import { Extension } from \"./interface\";\n\nexport class GreaterThanExtension extends Extension {\n  static name = \"greaterThan\" as const;\n\n  static async handler(...args: any[]): Promise<boolean | undefined> {\n    if (args.length !== 1) {\n      throw new Error(\"Greater Than Extension requires one argument.\");\n    }\n    const toCompare = args[0];\n    if (typeof toCompare !== \"string\") {\n      throw new Error(\"Greater Than Extension requires a string argument.\");\n    }\n\n    if(!isNaN(Number(this)) && !isNaN(Number(toCompare))) {\n        return Number(this) > Number(toCompare);\n    }\n\n    if (!isNaN(Date.parse(this.valueOf() as string)) && !isNaN(Date.parse(toCompare))) {\n        return (new Date(this.valueOf() as string)).getTime() > new Date(toCompare).getTime();\n    }\n    return this.valueOf() > toCompare;\n  }\n}","import { Extension } from \"./interface\";\n\nexport class LessThanExtension extends Extension {\n  static name = \"lessThan\" as const;\n\n  static async handler(...args: any[]): Promise<boolean | undefined> {\n    if (args.length !== 1) {\n      throw new Error(\"Less Than Extension requires one argument.\");\n    }\n    const toCompare = args[0];\n    if (typeof toCompare !== \"string\") {\n      throw new Error(\"Less Than Extension requires a string argument.\");\n    }\n\n    if(!isNaN(Number(this)) && !isNaN(Number(toCompare))) {\n        return Number(this) < Number(toCompare);\n    }\n\n    if (!isNaN(Date.parse(this.valueOf() as string)) && !isNaN(Date.parse(toCompare))) {\n        return (new Date(this.valueOf() as string)).getTime() < new Date(toCompare).getTime();\n    }\n    return this.valueOf() < toCompare;\n  }\n}","import { Extension } from \"./interface\";\n\nexport class EqualExtension extends Extension {\n  static name = \"equal\" as const;\n\n  static async handler(...args: any[]): Promise<boolean | undefined> {\n    if (args.length !== 1) {\n      throw new Error(\"Equal Extension requires one argument.\");\n    }\n    const toCompare = args[0];\n    if (typeof toCompare !== \"string\") {\n      throw new Error(\"Equal Extension requires a string argument.\");\n    }\n\n    if(!isNaN(Number(this)) && !isNaN(Number(toCompare))) {\n        return Number(this) === Number(toCompare);\n    }\n\n    if (!isNaN(Date.parse(this.valueOf() as string)) && !isNaN(Date.parse(toCompare))) {\n        return (new Date(this.valueOf() as string)).getTime() === new Date(toCompare).getTime();\n    }\n    return this.valueOf() === toCompare;\n  }\n}","export * from \"./interface\";\nimport { GreaterThanExtension } from \"./greaterthan\";\nimport { LessThanExtension } from \"./lessthan\";\nimport { EqualExtension } from \"./equal\";\n\nexport const extensions = {\n    [GreaterThanExtension.name]: GreaterThanExtension.handler,\n    [LessThanExtension.name]: LessThanExtension.handler,\n    [EqualExtension.name]: EqualExtension.handler,\n};","import { extensions } from \"./extension/index\";\n\ntype ExtensionsType = typeof extensions;\n\ndeclare global {\n    interface String extends ExtensionsType { }\n}\n\nconst StringPrototype = String.prototype as any;\n\nfor (const key of Object.keys(extensions)) {\n    StringPrototype.prototype[key] = function (...args: any[]) {\n        return extensions[key as keyof typeof extensions].apply(this, args);\n    };\n}"],"mappings":"AAAO,IAAeA,EAAf,cAAiC,MAAO,CAC7C,OAAO,KAAe,GACtB,aAAa,WAAWC,EAA2C,CACjE,MAAM,IAAI,MAAM,yBAAyB,CAC3C,CACF,ECHO,IAAMC,EAAN,cAAmCC,CAAU,CAClD,OAAO,KAAO,cAEd,aAAa,WAAWC,EAA2C,CACjE,GAAIA,EAAK,SAAW,EAClB,MAAM,IAAI,MAAM,+CAA+C,EAEjE,IAAMC,EAAYD,EAAK,CAAC,EACxB,GAAI,OAAOC,GAAc,SACvB,MAAM,IAAI,MAAM,oDAAoD,EAGtE,MAAG,CAAC,MAAM,OAAO,IAAI,CAAC,GAAK,CAAC,MAAM,OAAOA,CAAS,CAAC,EACxC,OAAO,IAAI,EAAI,OAAOA,CAAS,EAGtC,CAAC,MAAM,KAAK,MAAM,KAAK,QAAQ,CAAW,CAAC,GAAK,CAAC,MAAM,KAAK,MAAMA,CAAS,CAAC,EACpE,IAAI,KAAK,KAAK,QAAQ,CAAW,EAAG,QAAQ,EAAI,IAAI,KAAKA,CAAS,EAAE,QAAQ,EAEjF,KAAK,QAAQ,EAAIA,CAC1B,CACF,ECrBO,IAAMC,EAAN,cAAgCC,CAAU,CAC/C,OAAO,KAAO,WAEd,aAAa,WAAWC,EAA2C,CACjE,GAAIA,EAAK,SAAW,EAClB,MAAM,IAAI,MAAM,4CAA4C,EAE9D,IAAMC,EAAYD,EAAK,CAAC,EACxB,GAAI,OAAOC,GAAc,SACvB,MAAM,IAAI,MAAM,iDAAiD,EAGnE,MAAG,CAAC,MAAM,OAAO,IAAI,CAAC,GAAK,CAAC,MAAM,OAAOA,CAAS,CAAC,EACxC,OAAO,IAAI,EAAI,OAAOA,CAAS,EAGtC,CAAC,MAAM,KAAK,MAAM,KAAK,QAAQ,CAAW,CAAC,GAAK,CAAC,MAAM,KAAK,MAAMA,CAAS,CAAC,EACpE,IAAI,KAAK,KAAK,QAAQ,CAAW,EAAG,QAAQ,EAAI,IAAI,KAAKA,CAAS,EAAE,QAAQ,EAEjF,KAAK,QAAQ,EAAIA,CAC1B,CACF,ECrBO,IAAMC,EAAN,cAA6BC,CAAU,CAC5C,OAAO,KAAO,QAEd,aAAa,WAAWC,EAA2C,CACjE,GAAIA,EAAK,SAAW,EAClB,MAAM,IAAI,MAAM,wCAAwC,EAE1D,IAAMC,EAAYD,EAAK,CAAC,EACxB,GAAI,OAAOC,GAAc,SACvB,MAAM,IAAI,MAAM,6CAA6C,EAG/D,MAAG,CAAC,MAAM,OAAO,IAAI,CAAC,GAAK,CAAC,MAAM,OAAOA,CAAS,CAAC,EACxC,OAAO,IAAI,IAAM,OAAOA,CAAS,EAGxC,CAAC,MAAM,KAAK,MAAM,KAAK,QAAQ,CAAW,CAAC,GAAK,CAAC,MAAM,KAAK,MAAMA,CAAS,CAAC,EACpE,IAAI,KAAK,KAAK,QAAQ,CAAW,EAAG,QAAQ,IAAM,IAAI,KAAKA,CAAS,EAAE,QAAQ,EAEnF,KAAK,QAAQ,IAAMA,CAC5B,CACF,EClBO,IAAMC,EAAa,CACtB,CAACC,EAAqB,IAAI,EAAGA,EAAqB,QAClD,CAACC,EAAkB,IAAI,EAAGA,EAAkB,QAC5C,CAACC,EAAe,IAAI,EAAGA,EAAe,OAC1C,ECDA,IAAMC,EAAkB,OAAO,UAE/B,QAAWC,KAAO,OAAO,KAAKC,CAAU,EACpCF,EAAgB,UAAUC,CAAG,EAAI,YAAaE,EAAa,CACvD,OAAOD,EAAWD,CAA8B,EAAE,MAAM,KAAME,CAAI,CACtE","names":["Extension","args","GreaterThanExtension","Extension","args","toCompare","LessThanExtension","Extension","args","toCompare","EqualExtension","Extension","args","toCompare","extensions","GreaterThanExtension","LessThanExtension","EqualExtension","StringPrototype","key","extensions","args"]}