var r=class extends String{static name="";static handler(...t){throw new Error("Method not implemented.")}};var a=class extends r{static name="greaterThan";static handler(...t){if(t.length!==1)throw new Error("Greater Than Extension requires one argument.");let e=t[0];if(typeof e!="string")throw new Error("Greater Than Extension requires a string argument.");return!isNaN(Number(this))&&!isNaN(Number(e))?Number(this)>Number(e):!isNaN(Date.parse(this.valueOf()))&&!isNaN(Date.parse(e))?new Date(this.valueOf()).getTime()>new Date(e).getTime():this.valueOf()>e}};var s=class extends r{static name="lessThan";static handler(...t){if(t.length!==1)throw new Error("Less Than Extension requires one argument.");let e=t[0];if(typeof e!="string")throw new Error("Less Than Extension requires a string argument.");return!isNaN(Number(this))&&!isNaN(Number(e))?Number(this)<Number(e):!isNaN(Date.parse(this.valueOf()))&&!isNaN(Date.parse(e))?new Date(this.valueOf()).getTime()<new Date(e).getTime():this.valueOf()<e}};var i=class extends r{static name="equal";static handler(...t){if(t.length!==1)throw new Error("Equal Extension requires one argument.");let e=t[0];if(typeof e!="string")throw new Error("Equal Extension requires a string argument.");return!isNaN(Number(this))&&!isNaN(Number(e))?Number(this)===Number(e):!isNaN(Date.parse(this.valueOf()))&&!isNaN(Date.parse(e))?new Date(this.valueOf()).getTime()===new Date(e).getTime():this.valueOf()===e}};var o={[a.name]:a.handler,[s.name]:s.handler,[i.name]:i.handler};var m=String.prototype;for(let[n,t]of Object.entries(o))Object.defineProperty(m,n,{value:function(...e){return t.call(String(this),...e)},writable:!0,enumerable:!1,configurable:!0});
//# sourceMappingURL=index.js.map